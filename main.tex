\documentclass[12pt,italian]{report}
\usepackage{tesi}

\usepackage[a4paper]{geometry}		% Formato del foglio
\usepackage[italian]{babel}			% Supporto per l'italiano
\usepackage[utf8]{inputenc}			% Supporto per UTF-8
\usepackage[a-1b]{pdfx}				% File conforme allo standard PDF-A (obbligatorio per la consegna)

\usepackage{graphicx}				% Funzioni avanzate per le immagini
\usepackage{hologo}					% Bibtex logo with \hologo{BibTeX}
%\usepackage{epsfig}				% Permette immagini in EPS
%\usepackage{xcolor}				% Gestione avanzata dei colori
\usepackage{amssymb,amsmath,amsthm} % Simboli matematici
\usepackage{listings}				% Scrittura di codice
\usepackage{url}					% Visualizza e rendere interattii gli URL
\usepackage{hyperref}				% Rende interattivi i collegamenti interni

\def\myCDL{Corso di Laurea magistrale in\\Informatica}

% TITOLO TESI:
\def\myTitle{Studio e Sviluppo di un Sistema di Passthrough per TEE tra QEMU e Linux su Piattaforme ARM}

% AUTORE:
\def\myName{Marco Cutecchia}
\def\myMat{Matr. Nr. 983828}

% RELATORE E CORRELATORE:
\def\myRefereeA{Prof. Danilo Bruschi}

% ANNO ACCADEMICO
\def\myYY{2022-2023}

% Il seguente comando introduce un elenco delle figure dopo l'indice (facoltativo)
%\figurespagetrue

% Il seguente comando introduce un elenco delle tabelle dopo l'indice (facoltativo)
%\tablespagetrue

\begin{document}

\frontespizio
\afterpreface

% FIXME: Non compare sull'indice
\chapter*{Sommario}
\label{cap:sommario}

% + Chiediamo più servizi e dunque aumenta la superficie di attacco, ma un
%   buco anche in servizi non critici rischia di mettere a rischio l'intero
%   sistema
L'aumento dei servizi che vengono richiesti dai moderni dispositivi di
computazione ha creato un quesito: l'aspetto di sicurezza è diventato più
importante di prima, ma con la maggiore complessità di tali sistemi aumenta
anche la superficie di attacco.
Rimuovere funzionalità dal sistema principale per renderlo più sicuro non
è accettabile, ma è possibile isolare i servizi critici dal punto di vista
della sicurezza in ambienti di computazione separati.

Questa è l'idea alla base dei \textit{Trusted Execution Environment(TEE)},
creare un ambiente di computazione nel processore, isolato dal resto del
mondo non sicuro e dedicato solamente a quei software con requisiti di
sicurezza stringenti.

% + Molto diffusi su mobile, inizia ad esserci interesse su piattaforme cloud
%   (trusted computing)
Dato che gli smartphone stanno diventando sempre più critici per la nostra vita
i TEE sono estremamente diffusi in ambito mobile, dove la piattaforma ARM fa da
padrona, e ormai presenti su praticamente tutti i cellulari ma inizia a esserci
un crescente interesse al loro uso anche in ambito Desktop e, in particolare,
anche sui server grazie all'iniziativa \textit{Confidential Computing}.

% + Esistono soluzioni ma sono solo su piattaforme x86 via intel SGX che è una
%   implementazione molto particolare(approfondire)
% + Con il crescente interesse nell'uso di ARM sui server vogliamo scoprire
%   come integrare un TEE implementato via TrustZone in ambienti virtualizzati
Al momento di scrittura di questa tesi, il mercato server è principalmente
dominato da processori basati sull'architettura x86\_64, esiste però un
interesse nell'uso di processori basati su architettura ARM grazie alla loro
particolare efficienza energetica.
Lo scopo di questa tesi è studiare come è possibile rendere disponibili i
servizi offerti da un TEE conforme alla specifica GlobalPlatform anche ad
ambienti virtualizzati.

% + Implementato un prototipo tramite QEMU, Linux ed utilizzando OP-TEE come
%   test case di TEE
Il risultato è stato quello di una versione modificata dell'emulatore QEMU
per aggiungere un device virtuale per la comunicazione tra il guest e il TEE
disponibile all'host. Inoltre è stato sviluppato un driver per sistemi Linux
e testato su piattaforma ARM usando OP-TEE come TEE di prova.

% TODO: PARLA DI PROBLEMI

\chapter{Introduzione}
\label{sec:introduzione}


\chapter{Trusted Execution Environment}
\label{sec:tee}
% + Ambiente in cui è garantita l'integrita del codice in esecuzione
Un \textit{Trusted Execution Environment}(TEE) è un ambiente all'interno di
un dispositivo dove può essere eseguito del software con necessità di
sicurezza critiche.
Esempi di TEE includono Samsung Knox, Qualcomm QSEE,
AMD Platform Security Processor e OP-TEE.
Un software eseguito dentro un TEE prende il nome di
\textit{Trusted Application}(TA) e può offrire dei servizi a dei client
esterni al TEE, che prendono il nome di \textit{Client Application}(CA).
L'ambiente esterno al TEE, che prende il nome di
\textit{Rich Execution Environment}(REE), non può in alcun modo interferire
con il TEE; dunque il TEE è un ambiente isolato rispetto al REE.

Questa definizione è piuttosto generica, nella pratica il "come" questi
ambienti vengano realizzati, e quali proprietà di sicurezza vengano garantite
può variare significativamente tra i prodotti.
In questa tesi faremo riferimento ai documenti di specifica TEE di
GlobalPlatform, una organizzazione che si occupa di standardizzare sistemi
hardware per la sicurezza informatica.
In particolare, nel loro
\textit{TEE Security Profile}\cite{gp2020securityprofile}, GlobalPlatform
descrive il tipo di attacchi a cui un TEE deve resistere per essere
considerato conforme alla specifica.

Una analisi dettagliata di questi documenti è fuori dallo scopo di questa
tesi, ma in generale è possibile affermare che un TEE, per essere conforme
alla specifica GlobalPlatform, deve poter garantire la proprietà di esecuzione
isolata rispetto al REE e le proprietà d'integrità e confidenzialità sia del
codice sia degli assets generati da esso.

Le specifiche GlobalPlatform non restringono come queste proprietà devono
essere raggiunte, seppur proponga alcune soluzioni pratiche.
Nonostante ciò esistono comunque degli aspetti comuni alla maggior parte dei
TEE, come ad esempio l'uso di supporto hardware per realizzare l'isolamento
oppure l'uso di firme digitali per garantire l'autenticità del codice.

\paragraph{Isolamento:}
% TODO: Leggi per davvero l'articolo di rushby
Per garantire la proprietà d'isolamento dal REE, \cite{sabt2015tee} nota
che tutti i TEE implementano un \textit{separation kernel}
\cite{rushby1981separationkernel}. 
Un \textit{separation kernel} è un componente hardware e/o software fidato che
ha il compito di separare il sistema in zone isolate che non possono
interferire tra di loro e di mediare le comunicazioni tra di esse.
% FIXME: Sembra tanto l'idea di microkernel, bisogna approfondire la differenza
L'idea non è nuova, infatti venne proposta da Rushby nel 1981 dove propose
di vedere ogni singola macchina come un sistema distribuito di componenti
indipendenti, in questo modo un errore in un singolo componente non avrebbe
compromesso l'intero sistema.

Questa idea viene ripresa nel mondo dei TEE allo scopo di ridurre la
potenziale superficie di attacco del sistema, in questo modo se un
attaccante riesce a compromettere un singolo componente gli altri rimangono
intatti, assumendo che il \textit{separation kernel} non venga anch'esso
compromesso.

Nei sistemi operativi oggi in uso, come Linux o Windows, la superficie di
attacco è molto vasta a causa dell'enorme quantità di hardware che devono
supportare e il numero elevato di servizi, anche non critici per la sicurezza,
che offrono ai programmi utente. 
% FIXME: Qualche dato sulla dimensione di Linux/Windows? Dati sugli exploit in quali parte del sistema(driver)?
Un attaccante che riesce a penetrare nel kernel ottiene il massimo livello di
controllo sulla macchina, diventa dunque sensata l'idea di separare quei
servizi importanti per la sicurezza e d'isolarli dal resto del sistema in
un ambiente sicuro.

Per questo motivo è importante che il \textit{separation kernel} sia
il più semplice possibile, in modo che sia verificabile facilmente che non
contenga falle di sicurezza.
Seppur sia possibile avere molteplici TEE sullo stesso sistema, nella pratica
tutte le implementazioni si limitano a un singolo TEE, dunque il
"sistema distribuito" immaginato da Rushby è composto solamente da due
componenti, il TEE e il REE.

Esempi pratici di \textit{separation kernel} sono ARM TrustZone e
Trusted Firmware-A, blablabla.
% FIXME: Aggiungi e describi brevemente meglio esempi

\paragraph{Integrità e autenticità:}
I benefici ottenibili tramite l'isolazione del TEE vengono annullati se
l'integrità e l'autenticità del codice e assets all'interno del TEE non
vengono garantite. Se così non fosse, un attaccante potrebbe modificare
il codice del TEE mentre il dispositivo è spento per poi riaccenderlo con
il codice compromesso.

Queste proprietà devono essere garantite nell'intero ciclo di vita del
sistema, non è accettabile che esse non vengano assicurate fin dal primo boot,
o che queste proprietà vengano temporaneamente non garantite, pena
l'impossibilità di poter dichiarare il sistema come non compromesso.

Una soluzione per assicurare l'integrità e autenticità del codice consiste
nell'implementare un meccanismo di autenticazione usando delle chiavi
private conosciute solamente da enti fidati.
Ogni software, prima di poter essere caricato dentro il TEE, dovrà prima
passare un processo di autenticazione che consiste nel confrontare un hash
calcolato sul codice con un hash firmato incluso con il software.
Questo hash deve essere firmato utilizzando una chiave privata riconosciuta
dal TEE, in questo modo esso può verificare che un ente fidato ha approvato
l'esecuzione del codice.

Unica eccezione a questa regola è il primissimo software mandato in esecuzione
sul sistema; questo non può essere autenticato perché non è ancora presente
alcun software in esecuzione che possa effettuare il processo di verifica.
Per ovviare al problema, questo software viene caricato da una memoria
impossibile da sovrascrivere, come ad esempio le PROM, in questo modo è
possibile assumere comunque che il software non sia stato compromesso.

Questo meccanismo di autenticazione è molto simile a quello utilizzato per
implementare il \textit{Secure Boot}; la differenza con quest ultimo è che
nel \textit{Secure Boot} la catena di verifica del software termina con
l'avvio del sistema operativo, questo perché \textit{Secure Boot} si prefigge
di autenticare solamente processo di avvio del sistema operativo.
In un TEE, invece, si spinge più in avanti e si verificano anche i programmi
eseguiti al suo interno.

In entrambi i casi, però, è necessario che il firmware di un dispositivo
conosca le chiavi pubbliche per poter verificare la firma dei software
da caricare. Come queste chiavi vengano ottenute dal firmware è un dettaglio
implementativo, dunque altamente dipendente dal sistema.

Per esempio, su PC che implementano \textit{UEFI Secure Boot} queste chiavi
vengono spesse memorizzate su una piccola memoria inclusa nella scheda madre % FIXME: Cit. required
oppure dentro un \textit{Trusted Platform Module}, % FIXME: Cit. required (si usano i TPM per questo scopo?)
un piccolo chip dedicato a operazioni crittografiche.

\section{Applicazioni dei TEE}
\label{sec:applicazioni-tee}
I TEE sono largamente diffusi in ambito mobile al giorno d'oggi, seppur
raramente pubblicizzati.
Le applicazioni dei TEE sono molteplici ma sfortunatamente la grande
maggioranza dei produttori di dispositivi mobili non supportano
l'installazione di TA aggiuntive dopo la configurazione iniziale del TEE,
inoltre la mancanza d'interfacce standard per gli sviluppatori hanno reso
molto difficile sviluppare TA compatibili con TEE diversi.

Con la specifica dell'interfaccia GlobalPlatform TEE % FIXME: Cite spec
per gli sviluppatori di TA, lo sviluppo di TEE open-source come OP-TEE e lo
sforzo di player come Google, Softonic e Apple per rendere i propri TEE
conformi, potremmo vedere nei prossimi anni un uso più ampio dei TEE.

\paragraph{Secure Storage e salvataggio di chiavi crittografiche}

Una delle feature più comuni è l'uso dei TEE per la creazione del
\textit{Secure Storage}, una zona di memoria non volatile che possa rimanere
al sicuro anche quando il dispositivo è spento.
Questa area viene crittografata utilizzando una chiave conosciuta solamente
all'interno del TEE, inoltre è protetta da attacchi di tipo rollback.

% FIXME: Da riscrivere
Li dentro si salvano chiavi crittografiche ma anche informazioni non
necessariamente private ma di cui si vuole proteggere l'integrità, per esempio
il numero di tentativi fatti per accedere al dispositivo.

Un utilizzo molto comune di questa area sicura è il salvataggio di dati
come l'impronta digitale degli utenti, token per mantenere l'accesso a
servizi online oppure la gestione delle chiavi crittografiche.
Molti sviluppatori di applicazioni mobile Android e iOS utilizzano questa
funzionalità grazie ad API che, se presenti, utilizzano delle TA come ad
esempio "Keystore"\cite{androidkeystore} in Android.

Alcuni produttori, ad esempio AMD con il suo
\textit{Platform Security Processor}\cite{amd2020ftpm}, utilizzano queste
funzionalità per implementare un \textit{Trusted Platform Module}(TPM)
software, un co-processore dedicato a varie operazioni di crittografia, come
la generazione e salvataggio di chiavi e la verifica dell'integrità del
software in esecuzione sul sistema.
Grazie ai TEE i produttori possono potenzialmente risparmiare il costo di un
TPM hardware.

\paragraph{Protezione dei diritti di autore(DRM)}

Un'altra applicazione molto diffusa dei TEE è il loro utilizzo per la protezione
dei diritti di autore (DRM). Con la diffusione dei servizi di streaming, i
produttori di contenuti esitano a mettere a disposizione dei loro contenuti
perché temono che questi vengano condivisi con utenti che non hanno pagato
per accedervi.
Effettivamente sarebbe molto semplice per un utente utilizzare un software per
registrare il proprio schermo mentre guarda un film acquistato legalmente, per
poi condividerlo con altri utenti senza che questi debbano acquistarlo.

Sistemi come Widevine\cite{widevine} e PlayReady\cite{playready} vengono
integrati dai distributori di contenuti digitali allo scopo di impedire, o
almeno ostacolare, l'estrazione dei contenuti e la loro condivisione.
Questi sistemi hanno diversi livelli di protezione dei contenuti in base alle
capacità hardware del dispositivo; i produttori di contenuti possono richiedere
che un dispositivo supporti almeno un certo livello di sicurezza prima di
concedergli l'accesso ai propri contenuti.
Per esempio, alcuni servizi di streaming basati su Widevine richiedono che il
dispositivo raggiunga il livello L1 per poter usufruire di contenuti in alta
definizione; questo livello è raggiungibile solamente se presente un TEE con
la TA Widevine installata.

Il livello più alto di protezione che questi sistemi offrono è basato sui TEE,
che vengono usati per molteplici scopi tra cui: il provisioning di una chiave
crittografica condivisa tra server e client, la verifica delle licenze digitali
online e offline, la decrittazione degli stream audio/video e per mostrare
a schermo il video senza però che applicazioni esterne al TEE possano leggerne
i contenuti.
Per quest'ultima feature è necessario che sia presente un canale di
comunicazione fidato tra TEE e display, cioè che non dipenda dal REE, in modo
che un attaccante non possa leggere i pixel in chiaro che verranno mostrati poi
sullo schermo. 

\paragraph{Proposte esterne}

In letteratura sono state proposte diverse applicazioni dei TEE nelle più svariate aree.

% FIXME: Leggi meglio e comprendi l'articolo
In Javet, Anciaux et all\cite{edgeletcomputing} viene proposto di utilizzare i
TEE per realizzare un sistema di computazione "on the edge" sopra
"Opportunistic Networks"(OppNet), ovvero reti che sfruttano i
pattern di movimento degli utenti per creare reti temporanee.
In questo modello i TEE vengono usati per implementare un meccanismo di
attestazione remota per permettere ai dispositivi di verificare l'autenticità
dei dati ricevuti da altri dispositivi.

La rete XXX\cite{???} utilizza i TEE per implementare un meccanismo di consenso distribuito
blockchain blabla.

Infine \cite{??} pagamenti offline con TEE.

\section{TEE conformi GlobalPlatform}
\label{sec:tee-conformi-globalplatform}
GlobalPlatform è un consorzio di stakeholder interessati alla
standardizzazione di tecnologie per l'implementazione di servizi digitali
sicuri. L'organizzazione comprende produttori di hardware, sviluppatori di
sistemi operativi e applicazioni allo scopo di produrre dei documenti di
specifica allo scopo di favorire la collaborazione tra aziende e la
diffusione di nuove tecnologie nell'ambito della sicurezza informatica.

Nel 2010 GlobalPlatform ha pubblicato la prima versione dei documenti di
specifica per i TEE, oggi arrivati alla versione 1.3 pubblicati nel 2020.
Questi documenti, oltre al già citato \textit{Security Profile}, definiscono
una architettura generica di un TEE, API per la comunicazione tra CA e TA
e anche delle interfacce per permettere lo sviluppo di TA portabili tra TEE
diversi. Inoltre, GlobalPlatform pubblica anche delle raccomandazioni per
l'implementazione degli aspetti crittografici di un TEE.

% FIXME: Considera tradurre il testo in questa figura
% GPT TEE PP => Protection Profile
\begin{figure}
    \centering
    \includegraphics[width=1\textwidth]{immagini/tee-system-architecture}
    \caption{
        Architettura di un TEE conforme GlobalPlatform. 
        Da \textit{TEE System Architecture v1.3 (pag. 28)}
        \cite{gp2020systemarchitecture}
    }
    \label{fig:tee-system-architecture}
\end{figure}

In \figurename~\ref{fig:tee-system-architecture} una possibile architettura
software di un TEE conforme GlobalPlatform. 
In questa figura è possibile notare una barriera che divide TEE e REE; i due
mondi non possono accedere all'altro direttamente.
Client Application e Trusted Application possono condividere dei buffer di
memoria, ma questa è una astrazione implementata dal sistema sopra un
protocollo molto più semplice basato sullo scambio di messaggi.

Il passaggio dei messaggi avviene tramite il supporto dell'hardware, che in
questa architettura rappresenta il \textit{Separation Kernel} citato
precedentemente.

In entrambi i mondi è presente un sistema operativo che può mandare in
esecuzione dei processi e che contengono dei driver per l'accesso alle
periferiche. Queste si dividono in:
\begin{itemize}
    \item \textit{Periferiche Fidate}: L'accesso a queste periferiche è
    consentito solamente dal TEE. Esempi di queste periferiche sono i
    sensori biometrici oppure memorie segrete % FIXME: Sensori biometrici? Memorie segrete? non ne sono sicuro 
    \item \textit{Periferiche Fidate Condivise}: L'accesso a queste
    periferiche di default è consentito solamente dal TEE, ma questo può
    decidere temporaneamente di condividere l'accesso con il REE. Esempi di
    queste periferiche sono il display e la tastiera.
    \item \textit{Periferiche Pubbliche}: L'accesso diretto a queste
    periferiche avviene dal REE, ma nulla impedisce a quest'ultimo di
    permettere l'accesso anche al TEE tramite un driver. Esempi di queste
    periferiche sono gli altoparlanti.
\end{itemize}

Il flusso di esecuzione solito è il seguente: una Client Application richiede
un servizio a una Trusted Application, per fare ciò utilizza una API che
nasconde l'invio di un messaggio al \textit{TEE Communication Agent}.
Quest'ultimo inoltra il messaggio alla TA richiesta, inizializzandola se
questa non era già in esecuzione. La TA risponde con un messaggio che viene
inoltrato direttamente alla CA, che è rimasta in attesa nel frattempo.

% TODO: Parla del REE Communication Agent
%   * Permette comunicazione asincrona dato che normalmente sono sempre le CA ad iniziare
%   * Riceve le richieste dalle TA per tipo per leggere i file da disco

% TODO: Parla dell'internal core

\section{TEE e Cloud Computing}
\label{sec:tee-e-cloud-computing}
% + La situazione al momento: i dati sono al sicuro a macchina spenta ed in
%	transito, ma non quando sono caricati in memoria
Il modello di computing cloud permette di sfruttare le risorse di calcolo
disponibili in maniera efficiente e scalabile, ma allo stesso tempo introduce
nuovi problemi di sicurezza.
Questo modello richiede di permettere al cloud provider di controllare la
nostra macchina per poterla gestire e monitorare; se da un lato questo solleva
gli sviluppatori dal dover occuparsi di gestire le macchine, dall'altro ciò
comporta un rischio di sicurezza.
Infatti, se il cloud provider è in grado di controllare la nostra macchina,
questo significa che può anche leggere i dati in memoria, che sono al sicuro
solo quando la macchina è spenta o in transito.
% + Questo è potenzialmente un problema quando consideriamo che un attaccante
%   che riesce ad uscire dalla propria VM potrebbe leggere i dati in memoria
%   degli altri utenti sulla macchina
La situazione diventa ancora più problematica quando consideriamo che su
una singola macchina fisica i provider eseguono più macchine virtuali, ciascuna
di clienti diversi ma che condividono la stessa memoria fisica.
Ci sono stati molti esempi in passato di attaccanti che sono riusciti a eludere
le misure di sicurezza per isolare la propria VM dalle altre. % FIXME: Cit required
Questi attaccanti avrebbero avuto la possibilità non solo di spiare le altre
VM dei clienti che hanno avuto la sfortuna di risiedere sullo stesso server in
quel momento, ma anche di manipolare il loro codice per i loro scopi.
% + Non soltanto, vorremmo una maggiore sicurezza del fatto che il nostro software
%	è effettivamente quello in esecuzione sulla macchina nel cloud, cioè non
%	è stato modificato. Questo è il ben noto problema della attestazione
%   remota, uno dei problemi driver per la creazione dei TEE
Una organizzazione che dipende dal cloud e con particolari requisiti in
termini di sicurezza potrebbe dunque volere una sorta di garanzia che il
software che sta eseguendo sia quello che è stato consegnato al provider.
Questo è il ben noto problema della attestazione remota, uno dei problemi
driver per la creazione dei TEE. % FIXME: Cit. required
% + Confidential Computing Initiative è un consorzio di grandi aziende nel mondo
%	cloud che lavora a questo problema e che, al momento, trova nei TEE il modo
%	per risolverlo
La Confidential Computing Initiative\cite{confidential-computing-initiative}
è un consorzio di grandi aziende nel mondo cloud che lavora a questo problema
e che, al momento, trova nei TEE il modo per risolverlo.
Lo scopo dell'organizzazione è proprio quello di supportare lo sviluppo
di strumenti open source per garantire la sicurezza dei dati in memoria.
Questo è un campo di ricerca molto attivo e con molti progetti in corso ma
ancora poche soluzioni concrete e implementate.

Le soluzioni disponibili sul mercato fanno uso di Intel SGX
o AMD SEV, che descriviamo rispettivamente in \ref{sec:intel-sgx} e
\ref{sec:amd-sev}. Queste tecnologie sono disponibili solamente su processori
con architettura x86\_64 dei rispettivi produttori hardware.
Con un maggior interesse nell'utilizzo dell'architettura ARM lato server, % FIXME: Cit required
grazie alla sua maggior efficienza energetica, % FIXME: Cit required
vogliamo dunque trovare una soluzione equivalente per questa architettura.
% + Il modello standard dei TEE come implementato sui dispositivi mobile
%   non può essere trasposto direttamente, richiede di risolvere dei nuovi
%	problemi nati dal nuovo ambiente
Fino a oggi la gran parte degli sforzi rispetto all'uso dei TEE su ARM
si è concentrata su dispositivi mobile, ma il modello dei TEE come implementato
su questi dispositivi non può essere trasposto direttamente sui server,
richiede di risolvere dei nuovi problemi nati dal diverso ambiente.
In particolare i TEE dei dispositivi mobile sono pensati per essere usati
da un solo utente, mentre in un ambiente cloud è necessario che più utenti
possano usare la stessa macchina fisica e dunque che il TEE possa essere
condiviso.
Inoltre, il modello dei TEE mobile assume che il software rimanga legato a
un unico TEE per tutta la sua esecuzione; questa assunzione cade in ambito
cloud dato che una VM potrebbe essere trasferita su in qualunque momento su
una macchina fisica diversa, e dunque su un TEE diverso.

\section{Questioni Etiche nell'Uso dei TEE}
\label{sec:etica-tee}
I Trusted Execution Environment introducono una serie di questioni etiche
non ancora affrontate.
In letteratura nessuno ha ancora affrontato queste questioni rispetto ai TEE,
ma dato che TEE e Confidential Computing possono essere visti come una
evoluzione dei Trusted Platform Module (TPM) e del Trusted Computing 
% FIXME: cit. required
è possibile applicare le stesse considerazioni fatte per questi ultimi.
Nonostante ciò le analisi presenti rimangono poche; Stallman in
\cite{stallman2021tpm} fa notare che il concetto di Trusted Computing può
essere usato per limitare le azioni dell'utente e, nel suo breve articolo,
propone alcuni scenari in cui questo potrebbe accadere. 

% + Una root of trust intagliata nell'hardware significa che non abbiamo il
%   pieno controllo sul SW in esecuzione sulla nostra macchina
Questo è vero; un TEE può garantire le sue proprietà di sicurezza solamente
perché tutto il codice in esecuzione al suo interno è stato prima verificato
e firmato da una entità fidata.
Un singolo software insicuro può compromettere permanentemente la sicurezza
di un TEE, e quindi di tutto il sistema; non è possibile dunque permettere
l'esecuzione di qualunque software al suo interno.
Questa responsabilità è troppo grande per essere affidata a un utente,
in un certo senso dunque un TEE toglie all'utente la libertà di eseguire
qualunque software sulla propria macchina, richiedendo prima che questo
sia stato approvato da un ente già presente nel TEE.

% + Un TEE può avere controllo su tutto il computer senza che l'OS possa
%   notarlo
La situazione diventa ancora più problematica quando consideriamo che
molte piattaforme hardware, come ARM TrustZone, permettono d'interferire
con il sistema operativo in esecuzione sul REE. % FIXME: Cit. required
Un TEE ha accesso diretto all'hardware per poter implementare le sue proprietà
di sicurezza ma nulla gli impedisce, se non la buona volontà dei suoi
sviluppatori, di abusare di questo accesso per poter spiare il REE senza che
questo possa notarlo.
Un TEE può quindi avere il controllo totale del sistema e, dato che garantisce
la proprietà di confidenzialità sia delle memorie volatili che non, non è
possibile ispezionare il suo codice e la sua memoria mentre è in esecuzione.

% + La maggior parte dei vendor tiene un velo di segretezza rispetto ai
%   propri TEE
La maggior parte dei produttori non rilascia il codice sorgente dei propri TEE,
ma anche se così non fosse questo non garantisce che il codice in esecuzione
sia quello rilasciato, in quanto il TEE installato sul dispositivo potrebbe
essere stato modificato prima dell'installazione.
Non è neanche possibile per un utente ricompilare il TEE e installarlo
sul proprio dispositivo dato che, per design, la chiave per firmare il firmware
non dovrebbe essere può essere esportata dal produttore.

% + Sarebbe interessante studiare modi di garantire la root of trust
%   mantenendo l'inspectability (codice Open source prob non basta)
Un aspetto interessante, ma sfortunatamente non ancora esplorato in letteratura,
è come permettere agli utilizzatori di un TEE di verificarne il codice senza
comprometterne la sicurezza.
Seppur questo non risolva la questione della perdita di controllo sulla
propria macchina, almeno permetterebbe di avere un'idea di cosa stia eseguendo
il TEE.

\chapter{Hardware a supporto dei TEE}
\label{chap:hardware-supporto-tee}

\section{ARM TrustZone}
\label{sec:arm-trustzone}

\section{Intel SGX e TXT}
\label{sec:intel-sgx-txt}

\section{Processori esterni}
\label{sec:processori-esterni}
% AMD PSP
% Apple Secure Enclave
% Google Titan

\section{RISC-V}
\label{sec:risc-v}


\chapter{Passthrough per TEE tra QEMU e Linux}
\label{chap:passthrough-tee-qemu-linux}
% Breve intro a QEMU
% Descrizione di quello che vogliamo fare (permettere ad un TEE generico di offrire servizi a macchine virtuali)
% Interessante sia in ambito "casalingo" sia in ambito cloud per i provider

\section{OP-TEE}
\label{sec:architettura-op-tee}
% Descrizione di OP-TEE
% Cosa fa, perchè lo abbiamo scelto
% Architettura di OP-TEE, è molto simile a quella GlobalPlatform dunque parla
% dei confronti ed eventuali differenze (tipo: c'è il TF-A)

\section{GlobalPlatform API}
\label{sec:global-platform-api}
% Cosa è, cosa chiede di implementare
% (?) Forse poco per una sezione?

\section{Il sottosistema TEE per Linux}
\label{sec:sottosistema-tee-per-linux}
% Cosa è, perchè lo usiamo (perchè è una interfaccia comune)
% Funzionamento via ioctl

\section{Implementazione tramite l'Estensione del Kernel}
\label{sec:implementazione-passthrough-tramite-kernel-module}
% Descrizione del modulo Linux, modifiche a QEMU
% Comunicazione via MMIO
% Conversione di indirizzi virt/phys
% Gestione della shared memory
% Pro: è esplicito l'uso di un passthrough, facilmente cambiabile il passthrough sopra
% Contro: necessario estendere il kernel con un modulo

\section{Implementazione tramite l'Emulazione di OP-TEE}
\label{sec:implementazione-passthrough-tramite-bootloader}
% Cosa è OP-TEE
% Bootloader custom
% Descrizione del passaggio di parametri tra OP-TEE e bootloader
% Pro: passthrough invisibile, non serve estendere il kernel
% Contro: legato strettamente ad una singola versione di OP-TEE

\chapter{Testing}
\label{chap:testing}

\section{Setup dell'ambiente}
\label{sec:setup-ambiente}

\section{Preparazione della test suite}
\label{sec:preparazione-test-suite}

\section{Performance}
\label{sec:performance}

\chapter{Conclusioni}
\label{chap:conclusioni}


\section{Sviluppi Futuri}
\label{sec:sviluppi-futuri}

\appendix
\chapter{FakeTEE: Simulatore di TEE per aiutare nello sviluppo}
\label{chap:faketee}
% + Durante lo sviluppo era necessario avere un TEE ispezionabile facilmente
% + Con QEMU è possibile emularlo ma dato che volevo avere un TEE sull'host
%	accessibile da una VM guest sarebbe stato necessario avere una VM dentro
%	la VM durante lo sviluppo (scomodo!)
% + FakeTEE è un piccolo modulo per il kernel linux che si attacca al TEE subsystem
%	e finge la presenza di un TEE
% + Fa tutto in kernel space, non mantiene stato ed è facilmente modificabile e reloadable
% + Utile durante lo sviluppo di sw legato ai TEE 

\chapter{Impostazione dell'ambiente di sviluppo e testing}
\label{chap:impostazione-ambiente-sviluppo-testing}

\bibliographystyle{unsrt}
\bibliography{bibliografia}
\addcontentsline{toc}{chapter}{Bibliografia}

\end{document}
